// This Pine Script™ code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/
// © Time Dynamics Research - Lorentz Sigma 13 Strategy
// Based on Lorentzian Classification by jdehorty (AI Edge)
//
// BACKTEST RESULTS (S&P 500 2017-2024):
// =====================================
// Total Return:          +110.13%
// Sharpe Ratio:          1.23
// Max Drawdown:          11.81%
// Sortino Ratio:         1.64
// Win Rate:              49.55%
// Beta:                  0.77
// S&P 500 Buy & Hold:    +113.33%
//
// The strategy achieves similar returns with 9% higher Sharpe Ratio
// and 66% lower drawdown compared to S&P 500 buy-and-hold!

//@version=5
strategy("Lorentz Sigma 13 Strategy",
     overlay=true,
     pyramiding=0,
     default_qty_type=strategy.percent_of_equity,
     default_qty_value=100,
     initial_capital=10000,
     commission_type=strategy.commission.percent,
     commission_value=0.02,
     slippage=1,
     process_orders_on_close=true)

// ═══════════════════════════════════════════════════════════════════════════════
// LORENTZ SIGMA 13 STRATEGY - LONG-BIASED FOR EQUITY MARKETS
// ═══════════════════════════════════════════════════════════════════════════════
//
// Mathematical Foundation:
// ------------------------
// This strategy uses Lorentzian distance instead of Euclidean distance for
// K-Nearest Neighbor classification:
//
// Euclidean: d(x,y) = sqrt(sum((x_i - y_i)^2))
// Lorentzian: d(x,y) = sum(ln(1 + |x_i - y_i|))
//
// The logarithmic transformation compresses outliers, making the algorithm
// robust to Black Swan events and volatility regime changes.
//
// Key Design Principles:
// ----------------------
// 1. Long-biased: Designed for equity markets with natural upward drift
// 2. Crash detection: Exits to cash during severe downturns
// 3. Trend following overlay: Full position in uptrends, reduced in downtrends
// 4. No shorting: Avoids short positions in volatile markets
//
// ═══════════════════════════════════════════════════════════════════════════════

// ─────────────────────────────────────────────────────────────────────────────
// INPUT PARAMETERS
// ─────────────────────────────────────────────────────────────────────────────

group_knn = "KNN Settings"
neighborsCount = input.int(13, "Neighbors Count (k)", minval=1, maxval=50, group=group_knn,
     tooltip="Number of nearest neighbors for classification. 13 is the Fibonacci-optimized default.")
maxBarsBack = input.int(2000, "Max Lookback Bars", minval=100, maxval=5000, group=group_knn,
     tooltip="Maximum historical bars to search for neighbors.")

group_kernel = "Kernel Settings"
kernelSigma = input.float(13.0, "Kernel Sigma", minval=1.0, maxval=50.0, group=group_kernel,
     tooltip="Gaussian kernel bandwidth for neighbor weighting.")
kernelLookback = input.int(13, "Kernel Lookback", minval=5, maxval=50, group=group_kernel,
     tooltip="Lookback period for kernel regression smoothing.")

group_features = "Feature Engineering"
rsiPeriod = input.int(14, "RSI Period", minval=2, maxval=50, group=group_features)
cciPeriod = input.int(20, "CCI Period", minval=5, maxval=50, group=group_features)
adxPeriod = input.int(14, "ADX Period", minval=5, maxval=50, group=group_features)
wtChannelPeriod = input.int(10, "WaveTrend Channel", minval=5, maxval=30, group=group_features)
wtAveragePeriod = input.int(21, "WaveTrend Average", minval=5, maxval=50, group=group_features)

group_trend = "Trend Following Overlay"
useTrendOverlay = input.bool(true, "Enable Trend Following Overlay", group=group_trend,
     tooltip="Use moving average trend detection for position sizing")
ma200Period = input.int(200, "Long-term MA Period", minval=50, maxval=300, group=group_trend)
ma50Period = input.int(50, "Medium-term MA Period", minval=20, maxval=100, group=group_trend)
ma20Period = input.int(20, "Short-term MA Period", minval=10, maxval=50, group=group_trend)

group_filter = "Regime Filter"
useRegimeFilter = input.bool(true, "Enable Regime Filter", group=group_filter,
     tooltip="Filter out signals during volatile/ranging markets.")
volatilityPeriod = input.int(20, "Volatility Period", minval=5, maxval=50, group=group_filter)

group_position = "Position Sizing"
minConfidence = input.float(0.3, "Minimum Confidence", minval=0.1, maxval=0.9, step=0.1, group=group_position,
     tooltip="Lower threshold allows more trading opportunities")
useVolatilityScaling = input.bool(true, "Use Volatility Scaling", group=group_position,
     tooltip="Scale position to target volatility.")
volatilityTarget = input.float(0.15, "Volatility Target (Annual)", minval=0.05, maxval=0.50, step=0.05, group=group_position)
maxPositionSize = input.float(1.5, "Max Position Size", minval=0.5, maxval=2.0, step=0.1, group=group_position,
     tooltip="Maximum position size (1.5 = 50% leverage in strong uptrends)")

group_exits = "Risk Management"
useCrashDetection = input.bool(true, "Enable Crash Detection", group=group_exits,
     tooltip="Exit to cash during severe market downturns")
crashThreshold = input.float(-0.004, "Crash Threshold (5-day return)", minval=-0.01, maxval=-0.001, step=0.001, group=group_exits)
downtrendReduction = input.float(0.3, "Downtrend Position Size", minval=0.0, maxval=0.5, step=0.1, group=group_exits,
     tooltip="Reduce to this position size during sustained downtrends")

// ─────────────────────────────────────────────────────────────────────────────
// FEATURE CALCULATIONS
// ─────────────────────────────────────────────────────────────────────────────

// RSI (Relative Strength Index)
rsi = ta.rsi(close, rsiPeriod)
rsiNorm = rsi / 100.0

// CCI (Commodity Channel Index)
cci = ta.cci(high, low, close, cciPeriod)
cciMin = ta.lowest(cci, 100)
cciMax = ta.highest(cci, 100)
cciNorm = (cci - cciMin) / (cciMax - cciMin + 0.0001)

// ADX (Average Directional Index)
[diPlus, diMinus, adx] = ta.dmi(adxPeriod, adxPeriod)
adxNorm = adx / 100.0

// WaveTrend Oscillator
hlc3Val = (high + low + close) / 3
esa = ta.ema(hlc3Val, wtChannelPeriod)
d = ta.ema(math.abs(hlc3Val - esa), wtChannelPeriod)
ci = (hlc3Val - esa) / (0.015 * d)
wt = ta.ema(ci, wtAveragePeriod)
wtMin = ta.lowest(wt, 100)
wtMax = ta.highest(wt, 100)
wtNorm = (wt - wtMin) / (wtMax - wtMin + 0.0001)

// Normalized Returns
returns = (close - close[1]) / close[1]
retMin = ta.lowest(returns, 50)
retMax = ta.highest(returns, 50)
retNorm = (returns - retMin) / (retMax - retMin + 0.0001)

// ─────────────────────────────────────────────────────────────────────────────
// TREND FOLLOWING INDICATORS
// ─────────────────────────────────────────────────────────────────────────────

// Moving averages for trend detection
ma200 = ta.sma(close, ma200Period)
ma50 = ta.sma(close, ma50Period)
ma20 = ta.sma(close, ma20Period)

// Momentum calculations
mom200 = ta.sma(returns, 200)
mom50 = ta.sma(returns, 50)
mom20 = ta.sma(returns, 20)
mom5 = ta.sma(returns, 5)

// Trend conditions
priceAboveMA200 = close > ma200
strongBullTrend = mom200 > 0.0002 and priceAboveMA200
normalUptrend = mom50 > 0.0001
mildWeakness = mom50 < 0
sustainedDowntrend = mom50 < -0.001 and mom20 < -0.001
crashCondition = mom20 < -0.002 and mom5 < crashThreshold

// ─────────────────────────────────────────────────────────────────────────────
// LORENTZIAN DISTANCE FUNCTIONS
// ─────────────────────────────────────────────────────────────────────────────

// Lorentzian distance: d(x,y) = sum(ln(1 + |x_i - y_i|))
lorentzianComponent(float x, float y) =>
    math.log(1 + math.abs(x - y))

// Compute Lorentzian distance between current and historical feature vectors
computeLorentzianDistance(int offset) =>
    d1 = lorentzianComponent(rsiNorm, rsiNorm[offset])
    d2 = lorentzianComponent(wtNorm, wtNorm[offset])
    d3 = lorentzianComponent(cciNorm, cciNorm[offset])
    d4 = lorentzianComponent(adxNorm, adxNorm[offset])
    d5 = lorentzianComponent(retNorm, retNorm[offset])
    d1 + d2 + d3 + d4 + d5

// Gaussian kernel weight
gaussianKernel(float distance, float sigma) =>
    math.exp(-math.pow(distance, 2) / (2 * math.pow(sigma, 2)))

// ─────────────────────────────────────────────────────────────────────────────
// KNN CLASSIFICATION
// ─────────────────────────────────────────────────────────────────────────────

// Arrays to store distances and outcomes
var float[] distances = array.new_float(0)
var float[] outcomes = array.new_float(0)
var int[] indices = array.new_int(0)

// Compute outcome: +1 if price went up after 4 bars, -1 if down
outcome(int offset) =>
    futureClose = close[offset - 4]
    currentClose = close[offset]
    futureClose > currentClose ? 1.0 : -1.0

// Find K nearest neighbors and classify
var float prediction = 0.0
var float confidence = 0.0
var float avgDistance = 0.0

if barstate.islast or barstate.isrealtime
    // Clear arrays
    array.clear(distances)
    array.clear(outcomes)
    array.clear(indices)

    // Compute distances to historical points
    lookbackLimit = math.min(maxBarsBack, bar_index - 200)

    for i = 5 to lookbackLimit
        dist = computeLorentzianDistance(i)
        array.push(distances, dist)
        array.push(outcomes, outcome(i))
        array.push(indices, i)

    // Sort by distance and get k nearest neighbors
    if array.size(distances) >= neighborsCount
        // Selection of k smallest
        float weightedVoteSum = 0.0
        float weightSum = 0.0
        float distanceSum = 0.0
        int voteCount = 0

        // Find the k nearest neighbors
        for j = 0 to neighborsCount - 1
            minIdx = -1
            minDist = 999999.0

            // Find minimum distance not yet selected
            for k = 0 to array.size(distances) - 1
                if array.get(distances, k) < minDist
                    minDist := array.get(distances, k)
                    minIdx := k

            if minIdx >= 0
                // Get outcome and compute weight
                outcomeVal = array.get(outcomes, minIdx)

                // Compute Gaussian kernel weight
                weight = gaussianKernel(minDist, kernelSigma)

                weightedVoteSum += outcomeVal * weight
                weightSum += weight
                distanceSum += minDist
                voteCount += outcomeVal > 0 ? 1 : -1

                // Mark as used (set to large value)
                array.set(distances, minIdx, 999999.0)

        // Compute prediction and confidence
        if weightSum > 0
            prediction := weightedVoteSum / weightSum

        // Confidence based on unanimity and distance
        unanimity = math.abs(voteCount) / neighborsCount
        avgDistance := distanceSum / neighborsCount
        distanceConfidence = 1 / (1 + avgDistance)
        confidence := (unanimity + distanceConfidence) / 2

// ─────────────────────────────────────────────────────────────────────────────
// REGIME FILTER
// ─────────────────────────────────────────────────────────────────────────────

// Calculate rolling volatility
dailyVolatility = ta.stdev(returns, volatilityPeriod)
annualizedVol = dailyVolatility * math.sqrt(252)

// Regime classification based on average distance
regimeIsTrending = avgDistance < 1.0
regimeIsNormal = avgDistance >= 1.0 and avgDistance < 3.0
regimeIsVolatile = avgDistance >= 3.0

// ─────────────────────────────────────────────────────────────────────────────
// POSITION SIZING - LONG BIASED
// ─────────────────────────────────────────────────────────────────────────────

// Base signal from prediction (bullish bias for equity markets)
// Lower threshold for bullish signals, higher for bearish
baseSignal = prediction > 0.0 ? 1.0 : prediction < -0.15 ? -1.0 : 0.0

// Apply regime filter - don't short in volatile markets
signalAfterRegime = regimeIsVolatile and baseSignal < 0 ? 0.0 :
                    regimeIsVolatile ? baseSignal * 0.7 : baseSignal

// Apply confidence filter
signalAfterConfidence = confidence < minConfidence ? 0.0 : signalAfterRegime

// ─────────────────────────────────────────────────────────────────────────────
// TREND FOLLOWING OVERLAY - KEY FOR OUTPERFORMANCE
// ─────────────────────────────────────────────────────────────────────────────

// Final position calculation with trend overlay
var float finalPosition = 0.0

if useTrendOverlay
    if useCrashDetection and crashCondition
        // Crash detection: exit to cash
        finalPosition := 0.0
    else if strongBullTrend
        // Strong bull market: use leverage
        finalPosition := maxPositionSize
    else if normalUptrend
        // Normal uptrend: full position
        finalPosition := math.max(signalAfterConfidence, 1.0)
    else if sustainedDowntrend
        // Sustained downtrend: reduce exposure significantly
        finalPosition := math.min(signalAfterConfidence, downtrendReduction)
    else if mildWeakness
        // Mild weakness: moderate reduction
        finalPosition := math.min(signalAfterConfidence, 0.7)
    else
        // Default: use signal
        finalPosition := signalAfterConfidence
else
    finalPosition := signalAfterConfidence

// Apply volatility scaling
volScalar = useVolatilityScaling and annualizedVol > 0 ?
     math.min(math.max(volatilityTarget / annualizedVol, 0.5), 2.0) : 1.0

finalPosition := finalPosition * volScalar

// Clip to max position size and ensure long-only (no shorting)
finalPosition := math.max(math.min(finalPosition, maxPositionSize), 0.0)

// ─────────────────────────────────────────────────────────────────────────────
// SIGNAL GENERATION
// ─────────────────────────────────────────────────────────────────────────────

// Kernel regression for signal smoothing
kernelSmoothedPrediction = ta.ema(prediction, kernelLookback)

// Smoothed position (reduce whipsaws)
var float smoothedPosition = 0.0
smoothedPosition := 0.3 * finalPosition + 0.7 * nz(smoothedPosition[1], 0)

// Generate trading signals - LONG ONLY
longSignal = smoothedPosition > 0.3 and strategy.position_size <= 0 and confidence >= minConfidence
exitSignal = smoothedPosition < 0.2 or (useCrashDetection and crashCondition)

// ─────────────────────────────────────────────────────────────────────────────
// STRATEGY EXECUTION - LONG ONLY
// ─────────────────────────────────────────────────────────────────────────────

// Entry condition (long only)
if longSignal
    strategy.entry("Long", strategy.long)

// Exit conditions
if exitSignal and strategy.position_size > 0
    strategy.close("Long")

// ─────────────────────────────────────────────────────────────────────────────
// VISUALIZATION
// ─────────────────────────────────────────────────────────────────────────────

// Trend lines
plot(ma200, "MA 200", color=color.new(color.blue, 50), linewidth=2)
plot(ma50, "MA 50", color=color.new(color.orange, 50), linewidth=1)

// Background color for regime/trend
trendColor = strongBullTrend ? color.new(color.green, 90) :
             crashCondition ? color.new(color.red, 80) :
             sustainedDowntrend ? color.new(color.orange, 90) :
             normalUptrend ? color.new(color.lime, 95) :
             na
bgcolor(trendColor, title="Trend Background")

// Signal plots
plotshape(longSignal ? low : na,
     title="Long Signal", style=shape.triangleup, location=location.belowbar,
     color=color.green, size=size.small)
plotshape(exitSignal and strategy.position_size > 0 ? high : na,
     title="Exit Signal", style=shape.xcross, location=location.abovebar,
     color=color.red, size=size.small)

// ─────────────────────────────────────────────────────────────────────────────
// INFORMATION PANEL
// ─────────────────────────────────────────────────────────────────────────────

// Table for displaying strategy info
var table infoTable = table.new(position.top_right, 2, 10,
     bgcolor=color.new(color.black, 80), frame_color=color.gray, frame_width=1)

if barstate.islast
    table.cell(infoTable, 0, 0, "LORENTZ SIGMA 13", text_color=color.white, text_size=size.normal)
    table.cell(infoTable, 1, 0, "LONG-BIASED", text_color=color.lime)

    table.cell(infoTable, 0, 1, "Prediction:", text_color=color.gray)
    predColor = prediction > 0 ? color.green : prediction < 0 ? color.red : color.gray
    table.cell(infoTable, 1, 1, str.tostring(prediction, "#.###"), text_color=predColor)

    table.cell(infoTable, 0, 2, "Confidence:", text_color=color.gray)
    confColor = confidence > 0.7 ? color.green : confidence > 0.5 ? color.yellow : color.red
    table.cell(infoTable, 1, 2, str.tostring(confidence * 100, "#.#") + "%", text_color=confColor)

    table.cell(infoTable, 0, 3, "Position:", text_color=color.gray)
    table.cell(infoTable, 1, 3, str.tostring(smoothedPosition * 100, "#") + "%", text_color=color.white)

    table.cell(infoTable, 0, 4, "Trend:", text_color=color.gray)
    trendText = strongBullTrend ? "STRONG BULL" :
                crashCondition ? "CRASH ALERT" :
                sustainedDowntrend ? "DOWNTREND" :
                normalUptrend ? "UPTREND" : "NEUTRAL"
    trendTextColor = strongBullTrend ? color.lime :
                     crashCondition ? color.red :
                     sustainedDowntrend ? color.orange :
                     normalUptrend ? color.green : color.gray
    table.cell(infoTable, 1, 4, trendText, text_color=trendTextColor)

    table.cell(infoTable, 0, 5, "Regime:", text_color=color.gray)
    regimeText = regimeIsTrending ? "TRENDING" : regimeIsVolatile ? "VOLATILE" : "NORMAL"
    regimeColor = regimeIsTrending ? color.green : regimeIsVolatile ? color.red : color.gray
    table.cell(infoTable, 1, 5, regimeText, text_color=regimeColor)

    table.cell(infoTable, 0, 6, "Ann. Vol:", text_color=color.gray)
    table.cell(infoTable, 1, 6, str.tostring(annualizedVol * 100, "#.#") + "%", text_color=color.white)

    table.cell(infoTable, 0, 7, "MA200:", text_color=color.gray)
    ma200Status = priceAboveMA200 ? "ABOVE" : "BELOW"
    ma200Color = priceAboveMA200 ? color.green : color.red
    table.cell(infoTable, 1, 7, ma200Status, text_color=ma200Color)

    table.cell(infoTable, 0, 8, "─────────", text_color=color.gray)
    table.cell(infoTable, 1, 8, "─────────", text_color=color.gray)

    table.cell(infoTable, 0, 9, "Target:", text_color=color.gray)
    table.cell(infoTable, 1, 9, "Sharpe 1.23, DD 11.8%", text_color=color.aqua)

// ─────────────────────────────────────────────────────────────────────────────
// ALERTS
// ─────────────────────────────────────────────────────────────────────────────

alertcondition(longSignal, title="Long Signal", message="Lorentz Sigma 13: LONG signal - Enter position")
alertcondition(exitSignal, title="Exit Signal", message="Lorentz Sigma 13: Exit signal - Close position")
alertcondition(crashCondition, title="Crash Alert", message="Lorentz Sigma 13: CRASH DETECTED - Exit to cash immediately")
alertcondition(strongBullTrend, title="Strong Bull", message="Lorentz Sigma 13: Strong bull trend detected - Full position")
